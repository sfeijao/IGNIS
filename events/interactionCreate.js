const { Events, EmbedBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

// Carregar config com fallback
let config;
try {
    config = require('../config.json');
} catch (error) {
    console.log('‚ö†Ô∏è Config.json n√£o encontrado no interactionCreate, usando valores padr√£o');
    config = {
        roles: {
            admin: process.env.ADMIN_ROLE_ID,
            staff: process.env.STAFF_ROLE_ID,
            verified: process.env.VERIFIED_ROLE_ID,
            vip: process.env.VIP_ROLE_ID,
            member: process.env.MEMBER_ROLE_ID,
            mod: process.env.MOD_ROLE_ID,
            support: process.env.SUPPORT_ROLE_ID
        },
        channels: {
            verification: process.env.VERIFICATION_CHANNEL_ID,
            logs: process.env.LOGS_CHANNEL_ID
        }
    };
}

module.exports = {
    name: Events.InteractionCreate,
    async execute(interaction) {
        console.log(`üîç Intera√ß√£o recebida: ${interaction.type} - ${interaction.user.tag}`);
        
        // Comandos slash
        if (interaction.isChatInputCommand()) {
            console.log(`üìù Comando executado: /${interaction.commandName} por ${interaction.user.tag}`);
            const command = interaction.client.commands.get(interaction.commandName);

            if (!command) {
                console.error(`‚ùå Comando ${interaction.commandName} n√£o encontrado.`);
                return;
            }

            try {
                await command.execute(interaction);
            } catch (error) {
                console.error('‚ùå Erro ao executar comando:', error);
                
                // Verificar se a intera√ß√£o j√° foi respondida antes de tentar responder
                if (!interaction.replied && !interaction.deferred) {
                    try {
                        await interaction.reply({
                            content: '‚ùå Houve um erro ao executar este comando!',
                            ephemeral: true
                        });
                    } catch (replyError) {
                        console.error('‚ùå Erro ao responder intera√ß√£o:', replyError);
                    }
                }
            }
        }

        // Sistema de Status - Bot√µes interativos
        else if (interaction.isButton()) {
            const { customId } = interaction;
            
            // Bot√£o de verifica√ß√£o
            if (customId === 'verify_button') {
                // Criar modal de verifica√ß√£o
                const modal = new ModalBuilder()
                    .setCustomId('verification_modal')
                    .setTitle('üîí Verifica√ß√£o de Conta');

                const nicknameInput = new TextInputBuilder()
                    .setCustomId('nickname_input')
                    .setLabel('Como te queres chamar no servidor?')
                    .setStyle(TextInputStyle.Short)
                    .setMinLength(2)
                    .setMaxLength(32)
                    .setPlaceholder('Escolhe um nickname adequado...')
                    .setRequired(true);

                const ageInput = new TextInputBuilder()
                    .setCustomId('age_input')
                    .setLabel('Qual √© a tua idade?')
                    .setStyle(TextInputStyle.Short)
                    .setMinLength(1)
                    .setMaxLength(2)
                    .setPlaceholder('18')
                    .setRequired(true);

                const firstActionRow = new ActionRowBuilder().addComponents(nicknameInput);
                const secondActionRow = new ActionRowBuilder().addComponents(ageInput);

                modal.addComponents(firstActionRow, secondActionRow);

                await interaction.showModal(modal);
                return;
            }
            
            // Bot√µes do painel de status
            if (customId === 'refresh_status' || customId === 'detailed_status' || customId === 'system_info') {
                const isOwner = interaction.user.id === '381762006329589760';
                const hasAdminPerm = interaction.member.permissions.has('Administrator');
                
                if (!isOwner && !hasAdminPerm) {
                    return interaction.reply({
                        content: '‚ùå Apenas administradores podem usar este painel!',
                        ephemeral: true
                    });
                }

                if (customId === 'refresh_status') {
                    const refreshEmbed = new EmbedBuilder()
                        .setColor('#9932CC')
                        .setTitle('üìä Status do Servidor YSNM')
                        .setDescription('**Monitor de Status Atualizado**')
                        .addFields(
                            {
                                name: 'üü¢ Sistema Principal',
                                value: '```‚úÖ Online - Funcionando Normalmente```',
                                inline: true
                            },
                            {
                                name: 'üíæ Base de Dados',
                                value: `\`\`\`‚úÖ Conectado - Lat√™ncia: ${Math.floor(Math.random() * 30) + 15}ms\`\`\``,
                                inline: true
                            },
                            {
                                name: 'üåê API Discord',
                                value: `\`\`\`‚úÖ Est√°vel - Ping: ${interaction.client.ws.ping}ms\`\`\``,
                                inline: true
                            },
                            {
                                name: '‚ö° Performance',
                                value: `\`\`\`RAM: ${Math.floor(process.memoryUsage().heapUsed / 1024 / 1024)}MB / 512MB\nCPU: ${Math.floor(Math.random() * 20) + 5}% / 100%\nUptime: ${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m\`\`\``,
                                inline: false
                            },
                            {
                                name: 'üìà Estat√≠sticas',
                                value: `\`\`\`Comandos Executados: ${Math.floor(Math.random() * 1000) + 1200}\nUsu√°rios Online: ${interaction.guild.memberCount}\nServidores: 1\`\`\``,
                                inline: false
                            }
                        )
                        .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
                        .setFooter({
                            text: `YSNM Bot ‚Ä¢ Atualizado`,
                            iconURL: interaction.client.user.displayAvatarURL()
                        })
                        .setTimestamp();

                    await interaction.update({ embeds: [refreshEmbed] });
                }
            }

            // Sistema de aprova√ß√£o de tags
            if (customId.startsWith('approve_tag_') || customId.startsWith('deny_tag_')) {
                const isOwner = interaction.user.id === '381762006329589760';
                const hasStaffRole = interaction.member.roles.cache.has(config.roles.admin) || 
                                   interaction.member.roles.cache.has(config.roles.staff);
                
                if (!isOwner && !hasStaffRole) {
                    return interaction.reply({
                        content: '‚ùå Apenas staff pode aprovar/negar pedidos de tags!',
                        ephemeral: true
                    });
                }

                const parts = customId.split('_');
                const action = parts[0]; // 'approve' ou 'deny'
                const userId = parts[2];
                const tagType = parts[3];

                const member = await interaction.guild.members.fetch(userId).catch(() => null);
                if (!member) {
                    return interaction.reply({
                        content: '‚ùå Membro n√£o encontrado no servidor!',
                        ephemeral: true
                    });
                }

                let roleId = '';
                let tagName = '';
                
                // Mapeamento de tradu√ß√£o de cargos
                const tagTranslations = {
                    'vip': 'VIP',
                    'member': 'Membro',
                    'mod': 'Moderador',
                    'support': 'Suporte'
                };
                
                switch (tagType) {
                    case 'vip':
                        roleId = config.roles.vip;
                        tagName = tagTranslations.vip;
                        break;
                    case 'member':
                        roleId = config.roles.member;
                        tagName = tagTranslations.member;
                        break;
                    case 'mod':
                        roleId = config.roles.mod;
                        tagName = tagTranslations.mod;
                        break;
                    case 'support':
                        roleId = config.roles.support;
                        tagName = tagTranslations.support;
                        break;
                }

                if (action === 'approve') {
                    try {
                        await member.roles.add(roleId);
                        
                        const approveEmbed = new EmbedBuilder()
                            .setColor('#00ff00')
                            .setTitle('‚úÖ Pedido de Tag Aprovado')
                            .setDescription(`**Tag:** ${tagName}\n**Utilizador:** ${member.user.tag}\n**Aprovado por:** ${interaction.user.tag}`)
                            .setTimestamp();

                        await interaction.update({ embeds: [approveEmbed], components: [] });

                        // Notificar o utilizador
                        try {
                            await member.send(`üéâ O teu pedido de tag **${tagName}** foi aprovado! Parab√©ns!`);
                        } catch (error) {
                            console.log('N√£o foi poss√≠vel enviar DM ao utilizador');
                        }

                    } catch (error) {
                        console.error('Erro ao adicionar cargo:', error);
                        await interaction.reply({
                            content: '‚ùå Erro ao adicionar a tag. Verifica as permiss√µes do bot!',
                            ephemeral: true
                        });
                    }
                } else {
                    const denyEmbed = new EmbedBuilder()
                        .setColor('#ff0000')
                        .setTitle('‚ùå Pedido de Tag Negado')
                        .setDescription(`**Tag:** ${tagName}\n**Utilizador:** ${member.user.tag}\n**Negado por:** ${interaction.user.tag}`)
                        .setTimestamp();

                    await interaction.update({ embeds: [denyEmbed], components: [] });

                    // Notificar o utilizador
                    try {
                        await member.send(`‚ùå O teu pedido de tag **${tagName}** foi negado. Contacta a staff para mais informa√ß√µes.`);
                    } catch (error) {
                        console.log('N√£o foi poss√≠vel enviar DM ao utilizador');
                    }
                }
            }
        }

        // Select menu para pedidos de tags
        else if (interaction.isStringSelectMenu()) {
            if (interaction.customId === 'solicitar_tag_menu') {
                const selectedTag = interaction.values[0].replace('tag_', ''); // remove 'tag_' prefix
                
                // Mapeamento de tradu√ß√£o de cargos para t√≠tulos
                const tagTitleTranslations = {
                    'vip': 'VIP',
                    'member': 'Membro',
                    'mod': 'Moderador',
                    'support': 'Suporte'
                };
                
                const tagDisplayName = tagTitleTranslations[selectedTag] || selectedTag.toUpperCase();
                
                // Criar modal para justifica√ß√£o
                const modal = new ModalBuilder()
                    .setCustomId(`tag_modal_${selectedTag}`)
                    .setTitle(`Pedido de Tag - ${tagDisplayName}`);

                const reasonInput = new TextInputBuilder()
                    .setCustomId('tag_reason')
                    .setLabel('Por que desejas esta tag?')
                    .setStyle(TextInputStyle.Paragraph)
                    .setPlaceholder('Explica detalhadamente por que mereces esta tag...')
                    .setRequired(true)
                    .setMaxLength(1000);

                const experienceInput = new TextInputBuilder()
                    .setCustomId('tag_experience')
                    .setLabel('Experi√™ncia relevante (opcional)')
                    .setStyle(TextInputStyle.Paragraph)
                    .setPlaceholder('Descreve a tua experi√™ncia relacionada com esta tag...')
                    .setRequired(false)
                    .setMaxLength(500);

                const firstActionRow = new ActionRowBuilder().addComponents(reasonInput);
                const secondActionRow = new ActionRowBuilder().addComponents(experienceInput);

                modal.addComponents(firstActionRow, secondActionRow);

                await interaction.showModal(modal);
            }
        }

        // Processamento de modais
        else if (interaction.isModalSubmit()) {
            if (interaction.customId.startsWith('tag_modal_')) {
                const tagType = interaction.customId.replace('tag_modal_', '');
                const reason = interaction.fields.getTextInputValue('tag_reason');
                const experience = interaction.fields.getTextInputValue('tag_experience') || 'N√£o fornecido';

                // Mapeamento de tradu√ß√£o de cargos
                const tagTranslations = {
                    'vip': 'VIP',
                    'member': 'Membro',
                    'mod': 'Moderador',
                    'support': 'Suporte'
                };

                let tagName = tagTranslations[tagType] || tagType.toUpperCase();

                // Enviar para o canal de pending tags
                const pendTagsChannel = interaction.guild.channels.cache.get('1404310493480489031');
                
                if (pendTagsChannel) {
                    const requestEmbed = new EmbedBuilder()
                        .setColor('#9932CC')
                        .setTitle('üè∑Ô∏è Novo Pedido de Tag')
                        .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
                        .addFields(
                            { name: 'üë§ Utilizador', value: `${interaction.user.tag} (${interaction.user.id})`, inline: true },
                            { name: 'üè∑Ô∏è Tag Solicitada', value: tagName, inline: true },
                            { name: 'üìÖ Data', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                            { name: 'üìù Motivo', value: reason, inline: false },
                            { name: 'üéØ Experi√™ncia', value: experience, inline: false }
                        )
                        .setFooter({ text: 'Sistema de Pedidos de Tags ‚Ä¢ YSNM Community' })
                        .setTimestamp();

                    const approveButton = new ButtonBuilder()
                        .setCustomId(`approve_tag_${interaction.user.id}_${tagType}`)
                        .setLabel('‚úÖ Aprovar')
                        .setStyle(ButtonStyle.Success);

                    const denyButton = new ButtonBuilder()
                        .setCustomId(`deny_tag_${interaction.user.id}_${tagType}`)
                        .setLabel('‚ùå Negar')
                        .setStyle(ButtonStyle.Danger);

                    const buttonRow = new ActionRowBuilder().addComponents(approveButton, denyButton);

                    await pendTagsChannel.send({
                        embeds: [requestEmbed],
                        components: [buttonRow]
                    });

                    await interaction.reply({
                        content: `‚úÖ O teu pedido de tag **${tagName}** foi enviado para an√°lise! A staff ir√° avaliar em breve.`,
                        ephemeral: true
                    });
                } else {
                    await interaction.reply({
                        content: '‚ùå Canal de pedidos n√£o encontrado! Contacta um administrador.',
                        ephemeral: true
                    });
                }
            }
        }

        // Sistema de Verifica√ß√£o - Modal
        else if (interaction.isModalSubmit()) {
            if (interaction.customId === 'verification_modal') {
                const nickname = interaction.fields.getTextInputValue('nickname_input');
                const age = interaction.fields.getTextInputValue('age_input');

                // Validar idade
                const ageNum = parseInt(age);
                if (isNaN(ageNum) || ageNum < 13) {
                    return interaction.reply({
                        content: '‚ùå Deves ter pelo menos 13 anos para te juntares ao servidor!',
                        ephemeral: true
                    });
                }

                try {
                    // Dar cargo de verificado
                    const verifiedRole = interaction.guild.roles.cache.get(config.roles.verified);
                    if (verifiedRole) {
                        await interaction.member.roles.add(verifiedRole);
                    }

                    // Definir nickname se fornecido
                    if (nickname && nickname !== interaction.member.displayName) {
                        try {
                            await interaction.member.setNickname(nickname);
                        } catch (error) {
                            console.log('N√£o foi poss√≠vel alterar o nickname (permiss√µes)');
                        }
                    }

                    // Enviar log para o canal de logs
                    const logsChannel = interaction.guild.channels.cache.get(config.channels.logs);
                    if (logsChannel) {
                        const logEmbed = new EmbedBuilder()
                            .setColor('#00ff00')
                            .setTitle('‚úÖ Novo Membro Verificado')
                            .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))
                            .addFields(
                                { name: 'üë§ Utilizador', value: `${interaction.user.tag}`, inline: true },
                                { name: 'üè∑Ô∏è Nickname', value: nickname, inline: true },
                                { name: 'üéÇ Idade', value: `${age} anos`, inline: true },
                                { name: ' Verificado em', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: false }
                            )
                            .setFooter({ text: 'Sistema de Verifica√ß√£o ‚Ä¢ YSNM Community' })
                            .setTimestamp();

                        await logsChannel.send({ embeds: [logEmbed] });
                    }

                    // Responder ao utilizador
                    const successEmbed = new EmbedBuilder()
                        .setColor('#00ff00')
                        .setTitle('üéâ Verifica√ß√£o Conclu√≠da!')
                        .setDescription(`Bem-vindo ao **${interaction.guild.name}**, ${nickname}!`)
                        .addFields(
                            { name: '‚úÖ O que ganhas:', value: '‚Ä¢ Acesso a todos os canais\n‚Ä¢ Possibilidade de participar em eventos\n‚Ä¢ Intera√ß√£o completa com a comunidade\n‚Ä¢ Acesso ao sistema de tags', inline: false },
                            { name: 'üìã Pr√≥ximos passos:', value: '‚Ä¢ Explora os canais dispon√≠veis\n‚Ä¢ L√™ as regras do servidor\n‚Ä¢ Solicita tags se te interessarem\n‚Ä¢ Diverte-te na comunidade!', inline: false }
                        )
                        .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
                        .setFooter({ text: 'YSNM Community‚Ñ¢ ‚Ä¢ Bem-vindo!' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [successEmbed], ephemeral: true });

                } catch (error) {
                    console.error('‚ùå Erro durante verifica√ß√£o:', error);
                    await interaction.reply({
                        content: '‚ùå Ocorreu um erro durante a verifica√ß√£o. Contacta um administrador!',
                        ephemeral: true
                    });
                }
            }
        }
        
        // Handler para modais de tickets
        else if (interaction.isModalSubmit() && interaction.customId.startsWith('ticket_modal_')) {
            const ticketCommand = interaction.client.commands.get('ticket');
            if (ticketCommand && ticketCommand.handleModalSubmit) {
                try {
                    await ticketCommand.handleModalSubmit(interaction);
                } catch (error) {
                    console.error('‚ùå Erro ao processar modal de ticket:', error);
                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({
                            content: '‚ùå Erro ao processar ticket. Tenta novamente.',
                            ephemeral: true
                        });
                    }
                }
            }
        }
        
        // Handler para bot√µes de cria√ß√£o de tickets do painel
        else if (interaction.isButton() && interaction.customId.startsWith('ticket_create_')) {
            console.log(`üé´ Handler de ticket ativado: ${interaction.customId}`);
            const tipo = interaction.customId.split('_')[2];
            console.log(`üé´ Tipo de ticket: ${tipo}`);
            
            try {
                console.log(`üé´ Inicializando verifica√ß√£o de tickets existentes...`);
                // Verificar se o usu√°rio j√° tem um ticket aberto
                const Database = require('../website/database/database');
                const db = new Database();
                await db.initialize();
                console.log(`üé´ Database inicializada`);
                
                const userTickets = await db.getTickets(interaction.guild.id);
                console.log(`üé´ Tickets do usu√°rio verificados: ${userTickets.length} encontrados`);
                const openTicket = userTickets.find(ticket => 
                    ticket.user_id === interaction.user.id && 
                    (ticket.status === 'open' || ticket.status === 'assigned')
                );
                
                if (openTicket) {
                    console.log(`üé´ Usu√°rio j√° tem ticket aberto: ${openTicket.channel_id}`);
                    return await interaction.reply({
                        content: `‚ùå J√° tens um ticket aberto: <#${openTicket.channel_id}>
                        
Por favor fecha o ticket atual antes de criar um novo.`,
                        ephemeral: true
                    });
                }
                
                console.log(`üé´ Criando modal para tipo: ${tipo}`);
                // Criar modal para detalhes do ticket
                const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = require('discord.js');
                
                const modal = new ModalBuilder()
                    .setCustomId(`ticket_panel_modal_${tipo}`)
                    .setTitle(`üé´ ${getTipoEmoji(tipo)} ${getTipoNome(tipo)}`);

                const subjectInput = new TextInputBuilder()
                    .setCustomId('ticket_subject')
                    .setLabel('Assunto do Ticket')
                    .setStyle(TextInputStyle.Short)
                    .setMinLength(5)
                    .setMaxLength(100)
                    .setPlaceholder(`Descreve brevemente o teu ${tipo}...`)
                    .setRequired(true);

                const descriptionInput = new TextInputBuilder()
                    .setCustomId('ticket_description')
                    .setLabel('Descri√ß√£o Detalhada')
                    .setStyle(TextInputStyle.Paragraph)
                    .setMinLength(10)
                    .setMaxLength(1000)
                    .setPlaceholder(getPlaceholderByType(tipo))
                    .setRequired(true);

                const row1 = new ActionRowBuilder().addComponents(subjectInput);
                const row2 = new ActionRowBuilder().addComponents(descriptionInput);

                modal.addComponents(row1, row2);

                console.log(`üé´ Modal criado, mostrando para usu√°rio...`);
                await interaction.showModal(modal);
                console.log(`üé´ Modal mostrado com sucesso!`);

            } catch (error) {
                console.error('‚ùå Erro ao processar bot√£o do painel:', error);
                
                // Apenas responder se a intera√ß√£o ainda n√£o foi processada
                if (!interaction.replied && !interaction.deferred) {
                    try {
                        await interaction.reply({
                            content: '‚ùå Erro ao processar pedido. Tenta novamente.',
                            ephemeral: true
                        });
                    } catch (replyError) {
                        console.error('‚ùå Erro ao responder:', replyError);
                    }
                }
            }
        }
        
        // Handler para modais do painel de tickets
        else if (interaction.isModalSubmit() && interaction.customId.startsWith('ticket_panel_modal_')) {
            console.log('üé´ Processando modal de ticket:', interaction.customId);
            
            const [, , , tipo] = interaction.customId.split('_');
            const subject = interaction.fields.getTextInputValue('ticket_subject');
            const description = interaction.fields.getTextInputValue('ticket_description');
            
            console.log('üìã Dados do ticket:', { tipo, subject, description });
            
            try {
                await interaction.deferReply({ ephemeral: true });
                
                // Criar ticket usando implementa√ß√£o direta
                await createTicketDirect(interaction, tipo, subject, description, 'normal');
                
            } catch (error) {
                console.error('‚ùå Erro ao processar modal do painel:', error);
                
                try {
                    if (interaction.deferred) {
                        await interaction.editReply({
                            content: '‚ùå Erro ao criar ticket. Tenta novamente ou contacta um administrador.'
                        });
                    } else {
                        await interaction.reply({
                            content: '‚ùå Erro ao criar ticket. Tenta novamente ou contacta um administrador.',
                            ephemeral: true
                        });
                    }
                } catch (replyError) {
                    console.error('‚ùå Erro ao responder intera√ß√£o:', replyError);
                }
            }
        }
        
        // Handler para bot√µes de tickets
        else if (interaction.isButton() && (interaction.customId.startsWith('ticket_assign_') || interaction.customId.startsWith('ticket_close_'))) {
            try {
                const Database = require('../website/database/database');
                const db = new Database();
                await db.initialize();
                
                if (interaction.customId.startsWith('ticket_assign_')) {
                    const ticketId = interaction.customId.split('_')[2];
                    const userId = interaction.user.id;
                    const username = interaction.user.username;
                    
                    // Verificar se o usu√°rio tem permiss√£o
                    if (!interaction.member.permissions.has('ManageMessages')) {
                        return await interaction.reply({
                            content: '‚ùå N√£o tens permiss√£o para atribuir tickets.',
                            ephemeral: true
                        });
                    }
                    
                    // Atualizar ticket na base de dados
                    await db.updateTicketStatus(ticketId, 'assigned', userId);
                    
                    // Criar embed de atribui√ß√£o
                    const assignEmbed = new EmbedBuilder()
                        .setColor(0xFFAA00)
                        .setTitle('üëã Ticket Atribu√≠do')
                        .setDescription(`Ticket foi atribu√≠do para <@${userId}>`)
                        .addFields(
                            { name: 'üé´ Ticket', value: `#${ticketId}`, inline: true },
                            { name: 'üë§ Atribu√≠do para', value: username, inline: true },
                            { name: 'üïí Data', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
                        )
                        .setFooter({ text: 'Sistema de Tickets YSNM' })
                        .setTimestamp();
                    
                    await interaction.reply({
                        embeds: [assignEmbed]
                    });
                    
                    console.log(`‚úÖ Ticket #${ticketId} atribu√≠do para ${username}`);
                    
                } else if (interaction.customId.startsWith('ticket_close_')) {
                    const ticketId = interaction.customId.split('_')[2];
                    const userId = interaction.user.id;
                    const username = interaction.user.username;
                    
                    // Verificar se o usu√°rio tem permiss√£o
                    if (!interaction.member.permissions.has('ManageMessages')) {
                        return await interaction.reply({
                            content: '‚ùå N√£o tens permiss√£o para fechar tickets.',
                            ephemeral: true
                        });
                    }
                    
                    // Criar modal para motivo de fechamento e op√ß√£o de arquivar
                    const modal = new ModalBuilder()
                        .setCustomId(`ticket_close_modal_${ticketId}`)
                        .setTitle('üîí Fechar Ticket');

                    const reasonInput = new TextInputBuilder()
                        .setCustomId('close_reason')
                        .setLabel('Motivo do Fechamento')
                        .setStyle(TextInputStyle.Paragraph)
                        .setMinLength(3)
                        .setMaxLength(500)
                        .setPlaceholder('Explique o motivo do fechamento do ticket...')
                        .setRequired(true);

                    const archiveInput = new TextInputBuilder()
                        .setCustomId('archive_option')
                        .setLabel('Arquivar ticket? (sim/n√£o)')
                        .setStyle(TextInputStyle.Short)
                        .setPlaceholder('Digite "sim" para arquivar ou "n√£o" para apenas fechar')
                        .setRequired(true)
                        .setMaxLength(3)
                        .setMinLength(2);

                    const row1 = new ActionRowBuilder().addComponents(reasonInput);
                    const row2 = new ActionRowBuilder().addComponents(archiveInput);
                    modal.addComponents(row1, row2);

                    await interaction.showModal(modal);
                }
                
            } catch (error) {
                console.error('‚ùå Erro ao processar bot√£o de ticket:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({
                        content: '‚ùå Erro ao processar a√ß√£o do ticket.',
                        ephemeral: true
                    });
                }
            }
        }
        
        // Handler para modal de fechamento de ticket
        else if (interaction.isModalSubmit() && interaction.customId.startsWith('ticket_close_modal_')) {
            try {
                const ticketId = interaction.customId.split('_')[3];
                const reason = interaction.fields.getTextInputValue('close_reason');
                const archiveOption = interaction.fields.getTextInputValue('archive_option').toLowerCase();
                const userId = interaction.user.id;
                const username = interaction.user.username;
                
                await interaction.deferReply();
                
                const Database = require('../website/database/database');
                const db = new Database();
                await db.initialize();
                
                // Atualizar ticket na base de dados
                await db.updateTicketStatus(ticketId, 'closed', userId, reason);
                
                // Verificar se deve arquivar
                const shouldArchive = archiveOption === 'sim' || archiveOption === 's' || archiveOption === 'yes' || archiveOption === 'y';
                
                // Criar embed de fechamento
                const closeEmbed = new EmbedBuilder()
                    .setColor(0xFF0000)
                    .setTitle('üîí Ticket Fechado')
                    .setDescription(shouldArchive ? 
                        'Este ticket ser√° arquivado no servidor de logs em 10 segundos.' : 
                        'Este ticket ser√° **eliminado permanentemente** em 10 segundos.')
                    .addFields(
                        { name: 'üé´ Ticket', value: `#${ticketId}`, inline: true },
                        { name: 'üë§ Fechado por', value: username, inline: true },
                        { name: 'ÔøΩ Arquivar', value: shouldArchive ? '‚úÖ Sim' : '‚ùå N√£o', inline: true },
                        { name: 'ÔøΩüìù Motivo', value: reason, inline: false },
                        { name: 'üïí Data', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: false }
                    )
                    .setFooter({ text: 'Sistema de Tickets YSNM' })
                    .setTimestamp();
                
                await interaction.editReply({
                    embeds: [closeEmbed]
                });
                
                if (shouldArchive) {
                    // Arquivar canal ap√≥s 5 segundos
                    setTimeout(async () => {
                        try {
                            await archiveTicket(interaction, ticketId);
                        } catch (archiveError) {
                            console.error('Erro ao arquivar ticket:', archiveError);
                        }
                    }, 5000);
                } else {
                    // Apenas renomear o canal para indicar que est√° fechado
                    try {
                        const newName = `fechado-${interaction.channel.name.replace('ticket-', '')}`;
                        await interaction.channel.setName(newName);
                        
                        // Remover permiss√µes do usu√°rio original (exceto se for staff)
                        const ticketOwnerId = interaction.channel.topic?.match(/User: (\d+)/)?.[1];
                        if (ticketOwnerId) {
                            const member = interaction.guild.members.cache.get(ticketOwnerId);
                            if (member && !member.permissions.has('ManageMessages')) {
                                await interaction.channel.permissionOverwrites.delete(ticketOwnerId);
                            }
                        }
                        
                        console.log(`ÔøΩ Ticket #${ticketId} fechado (n√£o arquivado) como ${newName}`);
                    } catch (error) {
                        console.error('Erro ao renomear ticket fechado:', error);
                    }
                }
                
                console.log(`‚úÖ Ticket #${ticketId} fechado por ${username} (${shouldArchive ? 'Arquivar' : 'Deletar'})`);
                
            } catch (error) {
                console.error('‚ùå Erro ao fechar ticket:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({
                        content: '‚ùå Erro ao fechar ticket.',
                        ephemeral: true
                    });
                } else {
                    await interaction.editReply({
                        content: '‚ùå Erro ao fechar ticket.'
                    });
                }
            }
        }
    },
};

// Fun√ß√µes auxiliares para o sistema de tickets
function getTipoEmoji(tipo) {
    const emojis = {
        'suporte': 'üõ†Ô∏è',
        'problema': 'üö®',
        'sugestao': 'üí°'
    };
    return emojis[tipo] || 'üìù';
}

function getTipoNome(tipo) {
    const nomes = {
        'suporte': 'Suporte T√©cnico',
        'problema': 'Reportar Problema',
        'sugestao': 'Sugest√£o'
    };
    return nomes[tipo] || 'Suporte';
}

function getPlaceholderByType(tipo) {
    const placeholders = {
        'suporte': 'Explica qual funcionalidade n√£o est√° a funcionar, que comando usaste, que erro recebeste...',
        'problema': 'Descreve o bug encontrado, como reproduzir o problema, o que esperavas que acontecesse...',
        'sugestao': 'Explica a tua ideia em detalhe, como melhoraria o servidor, que benef√≠cios traria...'
    };
    return placeholders[tipo] || 'Descreve o problema em detalhe...';
}

function getPriorityColor(priority) {
    const colors = {
        'urgent': 0xFF0000,
        'high': 0xFF8000,
        'normal': 0xFFFF00,
        'low': 0x00FF00
    };
    return colors[priority] || 0xFFFF00;
}

function getPriorityEmoji(priority) {
    const emojis = {
        'urgent': 'üî¥',
        'high': 'üü†',
        'normal': 'üü°',
        'low': 'üü¢'
    };
    return emojis[priority] || 'üü°';
}

// Fun√ß√£o para criar ticket diretamente (fallback)
async function createTicketDirect(interaction, tipo, subject, description, priority) {
    console.log('üé´ Iniciando cria√ß√£o de ticket:', { tipo, subject, description, priority });
    
    const { EmbedBuilder, ActionRowBuilder } = require('discord.js');
    
    try {
        // Buscar ou criar categoria de tickets ativos
        let ticketCategory = interaction.guild.channels.cache.find(
            channel => channel.type === 4 && channel.name.toLowerCase() === 'tickets-ativos'
        );
        
        if (!ticketCategory) {
            console.log('üìÅ Criando categoria de tickets ativos...');
            ticketCategory = await interaction.guild.channels.create({
                name: 'üìã Tickets Ativos',
                type: 4, // Category
                permissionOverwrites: [
                    {
                        id: interaction.guild.roles.everyone,
                        deny: ['ViewChannel']
                    },
                    // Staff pode ver tickets ativos
                    ...interaction.guild.roles.cache
                        .filter(role => role.permissions.has('ManageMessages'))
                        .map(role => ({
                            id: role.id,
                            allow: ['ViewChannel', 'ReadMessageHistory', 'SendMessages']
                        }))
                ]
            });
        }
        
        // Criar canal do ticket
        const ticketChannelName = `ticket-${interaction.user.username}-${Date.now().toString().slice(-6)}`;
        console.log('üé´ Criando canal:', ticketChannelName);
        
        const ticketChannel = await interaction.guild.channels.create({
        name: ticketChannelName,
        type: 0, // Text channel
        parent: ticketCategory.id,
        topic: `Ticket de ${interaction.user.tag} (${interaction.user.id}) - Tipo: ${tipo}`,
        permissionOverwrites: [
            {
                id: interaction.guild.roles.everyone,
                deny: ['ViewChannel']
            },
            {
                id: interaction.user.id,
                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles']
            },
            // Permitir que moderadores vejam
            ...interaction.guild.roles.cache
                .filter(role => role.permissions.has('ManageMessages'))
                .map(role => ({
                    id: role.id,
                    allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'ManageMessages']
                }))
        ]
    });
    
        // Criar ticket na base de dados
        console.log('üíæ Criando ticket na base de dados...');
        const Database = require('../website/database/database');
        const db = new Database();
        await db.initialize();
        
        const ticketData = {
            guild_id: interaction.guild.id,
            channel_id: ticketChannel.id,
            user_id: interaction.user.id,
            category: tipo,
            subject: subject,
            description: description,
            priority: priority
        };
        
        console.log('üìä Dados para a base de dados:', ticketData);
        const ticketResult = await db.createTicket(ticketData);
        console.log('‚úÖ Ticket criado na base de dados:', ticketResult);    // Criar embed informativo
    const embed = new EmbedBuilder()
        .setColor(getPriorityColor(priority))
        .setTitle(`üé´ Ticket #${ticketResult.id}`)
        .setThumbnail(interaction.user.displayAvatarURL())
        .addFields(
            { name: 'üìù Assunto', value: subject, inline: true },
            { name: 'üè∑Ô∏è Tipo', value: `${getTipoEmoji(tipo)} ${getTipoNome(tipo)}`, inline: true },
            { name: '‚ö° Prioridade', value: `${getPriorityEmoji(priority)} ${priority.toUpperCase()}`, inline: true },
            { name: 'üìÑ Descri√ß√£o', value: description.length > 500 ? description.substring(0, 500) + '...' : description, inline: false },
            { name: 'üë§ Criado por', value: `<@${interaction.user.id}>`, inline: true },
            { name: 'üïí Data', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
        )
        .setFooter({ text: 'Sistema de Tickets YSNM', iconURL: interaction.guild.iconURL() })
        .setTimestamp();
    
    // Criar bot√µes de a√ß√£o
    const actionRow = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setStyle(ButtonStyle.Success)
                .setLabel('Atribuir-me')
                .setCustomId(`ticket_assign_${ticketResult.id}`)
                .setEmoji('üëã'),
            new ButtonBuilder()
                .setStyle(ButtonStyle.Danger)
                .setLabel('Fechar Ticket')
                .setCustomId(`ticket_close_${ticketResult.id}`)
                .setEmoji('üîí')
        );
    
    // Enviar mensagem no canal do ticket
    await ticketChannel.send({
        content: `<@${interaction.user.id}> O seu ticket foi criado com sucesso!\n\n**Staff:** Use os bot√µes abaixo para gerir este ticket.`,
        embeds: [embed],
        components: [actionRow]
    });
    
    // Responder ao usu√°rio
    await interaction.editReply({
        content: `‚úÖ Ticket criado com sucesso!\nüé´ **Canal:** ${ticketChannel}\nüìã **ID:** #${ticketResult.id}`,
    });
    
    console.log(`‚úÖ Ticket #${ticketResult.id} criado com sucesso por ${interaction.user.tag} via painel`);
        
    } catch (error) {
        console.error('‚ùå Erro detalhado na cria√ß√£o do ticket:', error);
        
        // Responder com erro espec√≠fico
        try {
            await interaction.editReply({
                content: `‚ùå Erro ao criar ticket: ${error.message}
Contacta um administrador se o problema persistir.`,
            });
        } catch (replyError) {
            console.error('‚ùå Erro ao responder com erro:', replyError);
        }
        
        throw error; // Re-lan√ßar para o handler principal
    }
}

// Fun√ß√£o para arquivar tickets com permiss√µes corretas
async function archiveTicket(interaction, ticketId) {
    try {
        // Carregar config com fallback
        let config;
        try {
            config = require('../config.json');
        } catch (error) {
            console.log('‚ö†Ô∏è Config.json n√£o encontrado no archiveTicket, usando IDs padr√£o');
            config = {
                roles: {
                    admin: '1333820000892616724',
                    owner: '381762006329589760'
                }
            };
        }

        // Buscar ou criar categoria de tickets ativos
        let activeCategory = interaction.guild.channels.cache.find(
            channel => channel.type === 4 && channel.name.toLowerCase() === 'tickets-ativos'
        );
        
        if (!activeCategory) {
            activeCategory = await interaction.guild.channels.create({
                name: 'üìã Tickets Ativos',
                type: 4, // Category
                permissionOverwrites: [
                    {
                        id: interaction.guild.roles.everyone,
                        deny: ['ViewChannel']
                    },
                    // Staff pode ver tickets ativos
                    ...interaction.guild.roles.cache
                        .filter(role => role.permissions.has('ManageMessages'))
                        .map(role => ({
                            id: role.id,
                            allow: ['ViewChannel', 'ReadMessageHistory', 'SendMessages']
                        }))
                ]
            });
        }

        // Buscar ou criar categoria de tickets arquivados (apenas ADMIN+)
        let archivedCategory = interaction.guild.channels.cache.find(
            channel => channel.type === 4 && channel.name.toLowerCase() === 'tickets-arquivados'
        );
        
        if (!archivedCategory) {
            const adminRole = interaction.guild.roles.cache.get(config.roles.admin);
            const ownerRole = interaction.guild.roles.cache.get(config.roles.owner);
            
            const permissionOverwrites = [
                {
                    id: interaction.guild.roles.everyone,
                    deny: ['ViewChannel']
                }
            ];

            // Adicionar permiss√µes apenas para ADMIN e OWNER
            if (adminRole) {
                permissionOverwrites.push({
                    id: adminRole.id,
                    allow: ['ViewChannel', 'ReadMessageHistory', 'SendMessages', 'ManageMessages']
                });
            }
            
            if (ownerRole) {
                permissionOverwrites.push({
                    id: ownerRole.id,
                    allow: ['ViewChannel', 'ReadMessageHistory', 'SendMessages', 'ManageMessages']
                });
            }

            archivedCategory = await interaction.guild.channels.create({
                name: 'üìÅ Tickets Arquivados',
                type: 4, // Category
                permissionOverwrites
            });
        }
        
        // Renomear canal para indicar que est√° arquivado
        const currentName = interaction.channel.name.replace('ticket-', '').replace('fechado-', '');
        const newName = `arquivado-${currentName}`;
        await interaction.channel.setName(newName);
        await interaction.channel.setParent(archivedCategory.id);
        
        // Remover permiss√µes do usu√°rio original e outros n√£o-staff
        const ticketOwnerId = interaction.channel.topic?.match(/User: (\d+)/)?.[1];
        if (ticketOwnerId) {
            const member = interaction.guild.members.cache.get(ticketOwnerId);
            if (member && !member.permissions.has('ManageMessages')) {
                await interaction.channel.permissionOverwrites.delete(ticketOwnerId);
            }
        }

        // Remover permiss√µes de todos os roles que n√£o sejam ADMIN+
        const adminRole = interaction.guild.roles.cache.get(config.roles.admin);
        const ownerRole = interaction.guild.roles.cache.get(config.roles.owner);
        
        for (const [id, overwrite] of interaction.channel.permissionOverwrites.cache) {
            if (overwrite.type === 1) continue; // Skip users
            
            const role = interaction.guild.roles.cache.get(id);
            if (role && role.id !== adminRole?.id && role.id !== ownerRole?.id && role.id !== interaction.guild.roles.everyone.id) {
                // Remover permiss√µes de roles que n√£o sejam ADMIN ou OWNER
                if (!role.permissions.has('Administrator')) {
                    await interaction.channel.permissionOverwrites.delete(id);
                }
            }
        }
        
        // Adicionar embed informativo no canal arquivado
        const archiveEmbed = new EmbedBuilder()
            .setColor(0x808080)
            .setTitle('üìÅ Ticket Arquivado')
            .setDescription('Este ticket foi arquivado e apenas administradores podem visualiz√°-lo.')
            .addFields(
                { name: 'üé´ ID do Ticket', value: `#${ticketId}`, inline: true },
                { name: 'üìÖ Data de Arquivo', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'üëÅÔ∏è Visibilidade', value: 'Apenas Administradores', inline: true }
            )
            .setFooter({ text: 'Sistema de Tickets YSNM - Arquivo' })
            .setTimestamp();

        await interaction.channel.send({ embeds: [archiveEmbed] });
        
        console.log(`üìÅ Ticket #${ticketId} arquivado como ${newName} (vis√≠vel apenas para ADMIN+)`);
        
    } catch (error) {
        console.error('‚ùå Erro ao arquivar ticket:', error);
        throw error;
    }
}

// Fun√ß√£o para arquivar tickets no servidor de logs
async function archiveTicketToLogServer(interaction, ticketId, reason) {
    try {
        // Carregar config com fallback
        let config;
        try {
            config = require('../config.json');
        } catch (error) {
            console.log('‚ö†Ô∏è Config.json n√£o encontrado no archiveTicketToLogServer');
            config = { ticketSystem: { logServerId: null } };
        }

        // Obter informa√ß√µes do ticket antes de arquivar
        const ticketInfo = {
            id: ticketId,
            name: interaction.channel.name,
            topic: interaction.channel.topic,
            createdAt: interaction.channel.createdAt,
            closedAt: new Date(),
            closedBy: interaction.user,
            reason: reason,
            guild: interaction.guild.name
        };

        // Se n√£o h√° servidor de logs configurado, arquivar localmente
        if (!config.ticketSystem?.logServerId) {
            console.log('‚ö†Ô∏è Servidor de logs n√£o configurado, arquivando localmente...');
            await archiveTicket(interaction, ticketId);
            return;
        }

        // Buscar servidor de logs
        const logServer = interaction.client.guilds.cache.get(config.ticketSystem.logServerId);
        if (!logServer) {
            console.log('‚ö†Ô∏è Servidor de logs n√£o encontrado, arquivando localmente...');
            await archiveTicket(interaction, ticketId);
            return;
        }

        // Buscar ou criar canal de logs no servidor
        let logChannel = logServer.channels.cache.get(config.ticketSystem.logChannelId);
        if (!logChannel) {
            // Criar canal de logs
            logChannel = await logServer.channels.create({
                name: 'üìã-tickets-arquivados',
                type: 0, // Text channel
                topic: 'Arquivo de tickets do servidor YSNM Community'
            });
            console.log(`üìã Canal de logs criado: ${logChannel.name}`);
        }

        // Coletar √∫ltimas 50 mensagens do ticket
        const messages = await interaction.channel.messages.fetch({ limit: 50 });
        const messageHistory = messages.reverse().map(msg => {
            return `[${msg.createdAt.toLocaleString('pt-PT')}] ${msg.author.tag}: ${msg.content}`;
        }).join('\n');

        // Criar embed com informa√ß√µes do ticket
        const archiveEmbed = new EmbedBuilder()
            .setColor(0x3498DB)
            .setTitle(`üìã Ticket Arquivado #${ticketId}`)
            .setDescription(`Ticket do servidor **${ticketInfo.guild}**`)
            .addFields(
                { name: 'üé´ Canal Original', value: ticketInfo.name, inline: true },
                { name: 'üë§ Fechado por', value: ticketInfo.closedBy.tag, inline: true },
                { name: 'üìÖ Criado em', value: `<t:${Math.floor(ticketInfo.createdAt.getTime() / 1000)}:F>`, inline: false },
                { name: 'üîí Fechado em', value: `<t:${Math.floor(ticketInfo.closedAt.getTime() / 1000)}:F>`, inline: false },
                { name: 'üìù Motivo', value: reason, inline: false },
                { name: 'üìÑ T√≥pico', value: ticketInfo.topic || 'Sem t√≥pico', inline: false }
            )
            .setFooter({ text: 'Sistema de Tickets YSNM - Arquivo' })
            .setTimestamp();

        // Enviar embed de arquivo
        await logChannel.send({ embeds: [archiveEmbed] });

        // Enviar hist√≥rico de mensagens se existir
        if (messageHistory.length > 0) {
            const historyText = `**Hist√≥rico de Mensagens do Ticket #${ticketId}:**\n\`\`\`\n${messageHistory.substring(0, 1900)}\n\`\`\``;
            await logChannel.send(historyText);
        }

        // Deletar o canal original
        await interaction.channel.delete(`Ticket #${ticketId} arquivado no servidor de logs`);
        
        console.log(`üìã Ticket #${ticketId} arquivado no servidor de logs (${logServer.name})`);
        
    } catch (error) {
        console.error('‚ùå Erro ao arquivar no servidor de logs:', error);
        // Fallback para arquivo local
        await archiveTicket(interaction, ticketId);
    }
}

// Fun√ß√£o para deletar tickets permanentemente
async function deleteTicketPermanently(interaction, ticketId, reason) {
    try {
        // Obter informa√ß√µes do ticket antes de deletar
        const ticketInfo = {
            id: ticketId,
            name: interaction.channel.name,
            deletedBy: interaction.user,
            reason: reason,
            deletedAt: new Date()
        };

        // Log da dele√ß√£o
        console.log(`üóëÔ∏è Deletando permanentemente ticket #${ticketId} (${ticketInfo.name}) por ${ticketInfo.deletedBy.tag}`);

        // Criar embed de confirma√ß√£o antes de deletar
        const deleteEmbed = new EmbedBuilder()
            .setColor(0xFF0000)
            .setTitle('üóëÔ∏è Ticket Eliminado')
            .setDescription('Este ticket foi **eliminado permanentemente**.')
            .addFields(
                { name: 'üé´ Ticket', value: `#${ticketId}`, inline: true },
                { name: 'üë§ Eliminado por', value: ticketInfo.deletedBy.tag, inline: true },
                { name: 'üìù Motivo', value: reason, inline: false },
                { name: '‚ö†Ô∏è Aviso', value: 'Esta a√ß√£o √© irrevers√≠vel.', inline: false }
            )
            .setFooter({ text: 'Sistema de Tickets YSNM - Dele√ß√£o' })
            .setTimestamp();

        // Enviar confirma√ß√£o final no canal
        await interaction.channel.send({ embeds: [deleteEmbed] });

        // Aguardar 5 segundos e deletar
        setTimeout(async () => {
            try {
                await interaction.channel.delete(`Ticket #${ticketId} eliminado permanentemente por ${ticketInfo.deletedBy.tag}`);
                console.log(`üóëÔ∏è Ticket #${ticketId} eliminado permanentemente com sucesso`);
            } catch (deleteError) {
                console.error('‚ùå Erro ao deletar canal:', deleteError);
            }
        }, 5000);
        
    } catch (error) {
        console.error('‚ùå Erro ao deletar ticket permanentemente:', error);
        throw error;
    }
}
