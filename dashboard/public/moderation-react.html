<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IGNIS - Centro de Moderação (React)</title>
  <link rel="stylesheet" href="/css/style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <!-- Tailwind (CDN for rapid integration) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Recharts -->
  <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
  <!-- Babel for JSX (development use) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    /* Subtle fade-in for new items */
    .fade-in { animation: fadeIn 250ms ease forwards; opacity: 0; }
    @keyframes fadeIn { to { opacity: 1; } }
    .scroll-area { max-height: calc(100vh - 220px); overflow: auto; }
  </style>
</head>
<body class="dense">
  <nav class="navbar">
    <div class="navbar-container">
      <div class="navbar-brand"><i class="fas fa-shield-halved"></i> Centro de Moderação</div>
      <div class="navbar-user">
        <a id="backDashboard" class="btn btn-glass"><i class="fas fa-home"></i> Dashboard</a>
      </div>
    </div>
  </nav>
  <main class="main-content">
    <div id="root" class="container"></div>
  </main>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;
    const { LineChart, Line, ResponsiveContainer, XAxis, YAxis, CartesianGrid, Tooltip, Legend } = Recharts;

    // Utils
    const getGuildId = () => {
      const params = new URLSearchParams(location.search);
      const urlId = params.get('guildId');
      if (urlId) return urlId;
      try { return localStorage.getItem('IGNIS_LAST_GUILD'); } catch { return null; }
    };

    const formatTime = (iso) => {
      try { const d = new Date(iso); return d.toLocaleString(); } catch { return iso; }
    };

    const TYPE_META = {
      'message_delete': { icon: 'fa-trash', color: 'text-red-400 border-red-500/30' },
      'message_edit':   { icon: 'fa-pen', color: 'text-amber-400 border-amber-500/30' },
      'member_join':    { icon: 'fa-user-plus', color: 'text-emerald-400 border-emerald-500/30' },
      'member_leave':   { icon: 'fa-user-minus', color: 'text-rose-400 border-rose-500/30' },
      'voice_join':     { icon: 'fa-volume-high', color: 'text-sky-400 border-sky-500/30' },
      'voice_leave':    { icon: 'fa-volume-off', color: 'text-sky-400 border-sky-500/30' },
      'voice_move':     { icon: 'fa-right-left', color: 'text-sky-400 border-sky-500/30' },
      'ban':            { icon: 'fa-ban', color: 'text-rose-400 border-rose-500/30' },
      'unban':          { icon: 'fa-unlock', color: 'text-lime-400 border-lime-500/30' },
      'warn':           { icon: 'fa-triangle-exclamation', color: 'text-yellow-400 border-yellow-500/30' },
      'mute':           { icon: 'fa-volume-xmark', color: 'text-amber-300 border-amber-500/30' },
      'kick':           { icon: 'fa-boot', color: 'text-orange-300 border-orange-500/30' },
    };
    const metaForType = (t) => {
      if (!t) return { icon: 'fa-circle-info', color: 'text-indigo-300 border-indigo-500/30' };
      const key = String(t).toLowerCase();
      for (const k of Object.keys(TYPE_META)) {
        if (key === k || key.startsWith(k)) return TYPE_META[k];
      }
      return { icon: 'fa-circle-info', color: 'text-indigo-300 border-indigo-500/30' };
    };

    // Filters Component
    function ModerationFilters({ value, onChange, onSearch, onReset, onExport, autoRefresh, setAutoRefresh }) {
      const [local, setLocal] = useState(value);
      useEffect(() => setLocal(value), [value]);
      const set = (k, v) => setLocal(prev => ({ ...prev, [k]: v }));
      const apply = () => onSearch(local);
      const reset = () => onReset();

      return (
        <div className="glass-card card-pad mb-8">
          <div className="grid grid-4 gap-12">
            <div>
              <label>Tipo</label>
              <select className="input" value={local.type} onChange={e=>set('type', e.target.value)}>
                <option value="">Todos</option>
                <option value="message_delete">Mensagens apagadas</option>
                <option value="message_edit">Mensagens editadas</option>
                <option value="member_*">Entradas/Saídas</option>
                <option value="voice_*">Eventos de voz</option>
                <option value="ban">Ban</option>
                <option value="unban">Unban</option>
                <option value="warn">Advertências</option>
                <option value="mute">Mutes</option>
                <option value="kick">Kicks</option>
              </select>
            </div>
            <div>
              <label>Moderador</label>
              <input className="input" placeholder="ID do moderador" value={local.moderatorId||''} onChange={e=>set('moderatorId', e.target.value)} />
            </div>
            <div>
              <label>Canal</label>
              <input className="input" placeholder="ID do canal" value={local.channelId||''} onChange={e=>set('channelId', e.target.value)} />
            </div>
            <div>
              <label>Utilizador</label>
              <input className="input" placeholder="ID do utilizador" value={local.userId||''} onChange={e=>set('userId', e.target.value)} />
            </div>
            <div>
              <label>De</label>
              <input type="date" className="input" value={local.from||''} onChange={e=>set('from', e.target.value)} />
            </div>
            <div>
              <label>Até</label>
              <input type="date" className="input" value={local.to||''} onChange={e=>set('to', e.target.value)} />
            </div>
            <div className="flex items-end gap-2">
              <button className="btn btn-primary" onClick={apply}><i className="fas fa-filter"></i> Aplicar</button>
              <button className="btn btn-glass" onClick={reset}><i className="fas fa-undo"></i> Limpar</button>
              <button className="btn btn-glass" onClick={()=>onExport('csv')}><i className="fas fa-file-csv"></i> CSV</button>
              <button className="btn btn-glass" onClick={()=>onExport('json')}><i className="fas fa-file-code"></i> JSON</button>
            </div>
            <div className="flex items-end gap-2">
              <label className="text-secondary"><input type="checkbox" className="mr-2" checked={autoRefresh} onChange={e=>setAutoRefresh(e.target.checked)} /> Atualização automática</label>
            </div>
          </div>
        </div>
      );
    }

    // Stats Component
    function ModerationStats({ logs }) {
      const stats = useMemo(() => {
        const agg = {};
        (logs||[]).forEach(l => {
          const t = (l.type||'').toLowerCase();
          const key = Object.keys(TYPE_META).find(k => t===k || t.startsWith(k)) || 'other';
          agg[key] = (agg[key]||0) + 1;
        });
        return Object.entries(agg).map(([k,v]) => ({ type:k, count:v }));
      }, [logs]);
      if (!stats.length) return null;
      return (
        <div className="grid grid-3 gap-12 mt-12">
          {stats.map(s => {
            const meta = metaForType(s.type);
            return (
              <div key={s.type} className="glass-card card-pad">
                <div className={`badge stat ${meta.color.replace('text-','')}`.trim()}>
                  <i className={`fas ${meta.icon}`}></i>
                  <span className="text-secondary">{s.type}</span>
                </div>
                <div className="mt-8 text-2xl font-bold">{s.count}</div>
              </div>
            );
          })}
        </div>
      );
    }

    function DetailsModal({ log, onClose }) {
      if (!log) return null;
      return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[2000]">
          <div className="glass-card p-6 w-full max-w-2xl">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-semibold"><i className="fas fa-circle-info mr-2"></i> Detalhes</h3>
              <button className="btn btn-glass btn-sm" onClick={onClose}><i className="fas fa-times"></i></button>
            </div>
            <pre className="text-sm overflow-auto max-h-[60vh] bg-white/5 border border-white/10 rounded p-3">{JSON.stringify(log, null, 2)}</pre>
            <div className="flex justify-end gap-2 mt-4">
              <button className="btn btn-primary" onClick={onClose}>Fechar</button>
            </div>
          </div>
        </div>
      );
    }

    function ModerationCard({ item, onDetails }) {
      const meta = metaForType(item.type);
      const user = item.resolved?.user?.username || item.data?.username || item.actor_id || 'Utilizador';
      const chan = item.resolved?.channel?.name || item.data?.channelId || '';
      return (
        <div className="fade-in border border-white/10 rounded-xl p-3 bg-white/5 shadow">
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-3">
              <div className={`w-9 h-9 rounded-full border flex items-center justify-center ${meta.color}`}>
                <i className={`fas ${meta.icon}`}></i>
              </div>
              <div>
                <div className="font-semibold">{user}</div>
                <div className="text-secondary text-sm">{item.type} • {formatTime(item.timestamp)}{chan?` • #${chan}`:''}</div>
              </div>
            </div>
            <button className="btn btn-glass btn-sm" onClick={()=>onDetails(item)}>
              <i className="fas fa-eye"></i> Ver detalhes
            </button>
          </div>
          {item.message && <div className="text-sm text-secondary mt-1">{item.message}</div>}
          {/* specific previews */}
          {item.type?.toLowerCase().startsWith('message_edit') && (
            <div className="mt-2 text-sm grid gap-2">
              {item.data?.old && <div><span className="text-secondary">Anterior:</span> {item.data.old}</div>}
              {item.data?.new && <div><span className="text-secondary">Nova:</span> {item.data.new}</div>}
            </div>
          )}
        </div>
      );
    }

    function ModerationFeed({ items, onDetails, onLoadMore, hasMore, loading }) {
      const listRef = useRef(null);
      return (
        <div className="glass-card card-pad">
          <div ref={listRef} className="scroll-area grid gap-3">
            {items.map(it => <ModerationCard key={`${it.id||it.timestamp}-${Math.random()}`} item={it} onDetails={onDetails} />)}
            {loading && <div className="text-center text-secondary py-3"><i className="fas fa-spinner fa-spin"></i> A carregar…</div>}
          </div>
          <div className="flex justify-center mt-4">
            {hasMore && !loading && (
              <button className="btn btn-glass" onClick={onLoadMore}><i className="fas fa-angles-down"></i> Carregar mais</button>
            )}
          </div>
        </div>
      );
    }

    function Charts({ data, period, onPeriod }) {
      const series = useMemo(() => {
        // Aggregate per day (simple client-side demo)
        const byDay = new Map();
        (data||[]).forEach(l => {
          const d = new Date(l.timestamp);
          const key = d.toISOString().slice(0,10);
          const t = (l.type||'').toLowerCase();
          const cat = Object.keys(TYPE_META).find(k => t===k || t.startsWith(k)) || 'other';
          if (!byDay.has(key)) byDay.set(key, { date:key, deletes:0, bans:0, voice:0, warns:0, other:0 });
          const row = byDay.get(key);
          if (cat.startsWith('message_delete')) row.deletes++;
          else if (cat.startsWith('ban')) row.bans++;
          else if (cat.startsWith('voice')) row.voice++;
          else if (cat.startsWith('warn')) row.warns++;
          else row.other++;
        });
        return Array.from(byDay.values()).sort((a,b)=>a.date.localeCompare(b.date));
      }, [data]);

      return (
        <div className="glass-card card-pad mt-12">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold"><i className="fas fa-chart-line mr-2"></i> Últimos {period==='24h'?'1 dia':period==='7d'?'7 dias':'30 dias'}</h3>
            <div className="flex gap-2">
              {['24h','7d','30d'].map(p => (
                <button key={p} className={`btn btn-sm ${p===period?'btn-primary':'btn-glass'}`} onClick={()=>onPeriod(p)}>{p.toUpperCase()}</button>
              ))}
            </div>
          </div>
          <div style={{height: 280}}>
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={series} margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.1)" />
                <XAxis dataKey="date" stroke="#B8BCC8" tick={{fill:'#B8BCC8'}} />
                <YAxis stroke="#B8BCC8" tick={{fill:'#B8BCC8'}} />
                <Tooltip contentStyle={{ background:'rgba(17,24,39,0.9)', border:'1px solid rgba(255,255,255,0.1)'}} />
                <Legend />
                <Line type="monotone" dataKey="deletes" stroke="#ef4444" dot={false} />
                <Line type="monotone" dataKey="bans" stroke="#a855f7" dot={false} />
                <Line type="monotone" dataKey="voice" stroke="#38bdf8" dot={false} />
                <Line type="monotone" dataKey="warns" stroke="#f59e0b" dot={false} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      );
    }

    function App() {
      const guildId = getGuildId();
      const [filters, setFilters] = useState({ type:'', moderatorId:'', channelId:'', userId:'', from:'', to:'' });
      const [items, setItems] = useState([]);
      const [loading, setLoading] = useState(false);
      const [offset, setOffset] = useState(0);
      const [hasMore, setHasMore] = useState(true);
      const [error, setError] = useState('');
      const [modal, setModal] = useState(null);
      const [autoRefresh, setAutoRefresh] = useState(true);
      const [period, setPeriod] = useState('7d');

      // Back to dashboard link (preserve guild)
      useEffect(() => {
        const dash = document.getElementById('backDashboard');
        if (dash) {
          const gid = guildId || '';
          dash.href = gid ? `/dashboard?guildId=${encodeURIComponent(gid)}` : '/dashboard';
        }
      }, [guildId]);

      const buildQuery = (extra = {}) => {
        const p = new URLSearchParams();
        const f = { ...filters, ...extra };
        if (f.type) p.set('type', f.type);
        if (f.moderatorId) p.set('moderatorId', f.moderatorId);
        if (f.channelId) p.set('channelId', f.channelId);
        if (f.userId) p.set('userId', f.userId);
        if (f.from) p.set('from', f.from);
        if (f.to) p.set('to', f.to);
        p.set('limit', String(50));
        p.set('offset', String(extra.offset ?? offset));
        return p.toString();
      };

      const fetchLogs = async (opts = { append:false, resetOffset:false }) => {
        if (!guildId) { setError('guildId em falta'); return; }
        if (opts.resetOffset) setOffset(0);
        setLoading(true); setError('');
        try {
          const query = buildQuery({ offset: opts.resetOffset ? 0 : offset });
          const r = await fetch(`/api/guild/${guildId}/logs?${query}`, { credentials: 'same-origin' });
          if (!r.ok) throw new Error('Falha ao carregar logs');
          const d = await r.json();
          const list = Array.isArray(d.logs) ? d.logs : [];
          setHasMore(list.length === 50);
          setItems(prev => opts.append ? [...prev, ...list] : list);
          if (opts.append) setOffset(prev => prev + list.length);
          else setOffset(list.length);
        } catch (e) {
          setError(e.message || 'Erro ao buscar');
        } finally {
          setLoading(false);
        }
      };

      // Initial load
      useEffect(() => { fetchLogs({ append:false, resetOffset:true }); }, [guildId]);

      // Auto-refresh polling
      useEffect(() => {
        if (!autoRefresh) return;
        const id = setInterval(() => fetchLogs({ append:false, resetOffset:true }), 15000);
        return () => clearInterval(id);
      }, [autoRefresh, guildId, filters]);

      const onSearch = (f) => { setFilters(f); fetchLogs({ append:false, resetOffset:true }); };
      const onReset = () => { setFilters({ type:'', moderatorId:'', channelId:'', userId:'', from:'', to:'' }); fetchLogs({ append:false, resetOffset:true }); };
      const onExport = (format) => {
        const q = buildQuery();
        const a = document.createElement('a');
        a.href = `/api/guild/${guildId}/logs/export?format=${encodeURIComponent(format)}&${q}`;
        a.download = `logs.${format}`;
        document.body.appendChild(a); a.click(); a.remove();
      };

      return (
        <section className="dashboard-section fade-in">
          <div className="section-header">
            <h1 className="section-title"><i className="fas fa-shield-halved"></i> Centro de Moderação</h1>
            <p className="text-secondary">Logs em tempo real e filtros avançados.</p>
          </div>

          <ModerationFilters
            value={filters}
            onChange={setFilters}
            onSearch={onSearch}
            onReset={onReset}
            onExport={onExport}
            autoRefresh={autoRefresh}
            setAutoRefresh={setAutoRefresh}
          />

          <ModerationStats logs={items} />

          <div className="mt-12 grid grid-1 gap-12">
            <ModerationFeed
              items={items}
              onDetails={setModal}
              onLoadMore={() => fetchLogs({ append:true })}
              hasMore={hasMore}
              loading={loading}
            />
          </div>

          <Charts data={items} period={period} onPeriod={setPeriod} />

          {error && <div className="mt-4 text-red-400">{error}</div>}
          {modal && <DetailsModal log={modal} onClose={()=>setModal(null)} />}
        </section>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);

    // Ensure back to dashboard respects stored guild
    (function ensureBackLink(){
      try {
        const gid = getGuildId();
        const el = document.getElementById('backDashboard');
        if (el) el.href = gid ? `/dashboard?guildId=${encodeURIComponent(gid)}` : '/dashboard';
      } catch {}
    })();
  </script>
</body>
</html>
